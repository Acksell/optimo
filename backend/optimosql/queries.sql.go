// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package optimosql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPurchaseOrder = `-- name: CreatePurchaseOrder :exec
INSERT INTO purchase_orders (
    supplier_id,
    order_date,
    estimated_delivery_date,
    product_id,
    quantity
) VALUES (
    $1,       -- supplier_id
    $2,        -- order_date
    $3,        -- estimated_delivery_date
    $4,                   -- product_id
    $5                  -- quantity
)
`

type CreatePurchaseOrderParams struct {
	SupplierID            string
	OrderDate             pgtype.Date
	EstimatedDeliveryDate pgtype.Date
	ProductID             int32
	Quantity              int32
}

// Insert a new purchase order
func (q *Queries) CreatePurchaseOrder(ctx context.Context, arg CreatePurchaseOrderParams) error {
	_, err := q.db.Exec(ctx, createPurchaseOrder,
		arg.SupplierID,
		arg.OrderDate,
		arg.EstimatedDeliveryDate,
		arg.ProductID,
		arg.Quantity,
	)
	return err
}

const deletePurchaseOrder = `-- name: DeletePurchaseOrder :exec
DELETE FROM purchase_orders
WHERE id = $1
`

func (q *Queries) DeletePurchaseOrder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePurchaseOrder, id)
	return err
}

const listPurchaseOrders = `-- name: ListPurchaseOrders :many
SELECT
    po.id,
    po.supplier_id,
    po.order_date,
    po.estimated_delivery_date,
    po.quantity,
    p.name AS product_name,
    p.brand AS product_brand,
    po.created_at
FROM purchase_orders po
JOIN products p ON po.product_id = p.id
ORDER BY po.order_date DESC
`

type ListPurchaseOrdersRow struct {
	ID                    int32
	SupplierID            string
	OrderDate             pgtype.Date
	EstimatedDeliveryDate pgtype.Date
	Quantity              int32
	ProductName           string
	ProductBrand          pgtype.Text
	CreatedAt             pgtype.Timestamp
}

// List all purchase orders with key details
func (q *Queries) ListPurchaseOrders(ctx context.Context) ([]ListPurchaseOrdersRow, error) {
	rows, err := q.db.Query(ctx, listPurchaseOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPurchaseOrdersRow
	for rows.Next() {
		var i ListPurchaseOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.SupplierID,
			&i.OrderDate,
			&i.EstimatedDeliveryDate,
			&i.Quantity,
			&i.ProductName,
			&i.ProductBrand,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthSales = `-- name: MonthSales :many
SELECT
    DATE_TRUNC('month', sale_date) AS year_month,
    product_id,
    SUM(quantity) AS inventory_turnover,
    SUM(quantity * price) AS sales_turnover
FROM sales
WHERE sale_date BETWEEN $1 AND $2
GROUP BY year_month, product_id
ORDER BY year_month, product_id
`

type MonthSalesParams struct {
	SaleDate   pgtype.Date
	SaleDate_2 pgtype.Date
}

type MonthSalesRow struct {
	YearMonth         pgtype.Interval
	ProductID         int32
	InventoryTurnover int64
	SalesTurnover     int64
}

// Sales per month (aggregated)
func (q *Queries) MonthSales(ctx context.Context, arg MonthSalesParams) ([]MonthSalesRow, error) {
	rows, err := q.db.Query(ctx, monthSales, arg.SaleDate, arg.SaleDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonthSalesRow
	for rows.Next() {
		var i MonthSalesRow
		if err := rows.Scan(
			&i.YearMonth,
			&i.ProductID,
			&i.InventoryTurnover,
			&i.SalesTurnover,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthSalesFiltered = `-- name: MonthSalesFiltered :many
SELECT
    DATE_TRUNC('month', sale_date) AS year_month,
    product_id,
    SUM(quantity) AS inventory_turnover,
    SUM(quantity * price) AS sales_turnover
FROM sales
WHERE sale_date BETWEEN $1 AND $2 AND product_id = ANY (UNNEST($3::int[]))
GROUP BY year_month, product_id
ORDER BY year_month, product_id
`

type MonthSalesFilteredParams struct {
	SaleDate   pgtype.Date
	SaleDate_2 pgtype.Date
	Column3    []int32
}

type MonthSalesFilteredRow struct {
	YearMonth         pgtype.Interval
	ProductID         int32
	InventoryTurnover int64
	SalesTurnover     int64
}

// Sales per month (aggregated) filtered by product IDs
func (q *Queries) MonthSalesFiltered(ctx context.Context, arg MonthSalesFilteredParams) ([]MonthSalesFilteredRow, error) {
	rows, err := q.db.Query(ctx, monthSalesFiltered, arg.SaleDate, arg.SaleDate_2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonthSalesFilteredRow
	for rows.Next() {
		var i MonthSalesFilteredRow
		if err := rows.Scan(
			&i.YearMonth,
			&i.ProductID,
			&i.InventoryTurnover,
			&i.SalesTurnover,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
